name: ci_cd_pipeline

on:
  push:
    branches:
      - "main"
      - "development"
  workflow_dispatch:

concurrency:
  group: production-deployment
  cancel-in-progress: true

env:
  #########################################
  #   GENERAL
  #########################################
  SHH_USER_PASSWORD: ${{ secrets.SHH_USER_PASSWORD }}
  DOCKER_HUB_USERNAME: ${{ vars.DOCKER_HUB_USERNAME }}
  DOCKER_HUB_PASSWORD: ${{ secrets.DOCKER_HUB_PASSWORD }}
  DOCKER_IMAGE: ${{ vars.DOCKER_HUB_USERNAME }}/${{ vars.DOCKER_HUB_APP_IMAGE }}

  #########################################
  #   ENVIRONMENT
  #########################################
  DOCKER_IMAGE_VERSION: ${{ vars.DOCKER_IMAGE_VERSION }}
  DOCKER_CONTAINER_NAME: ${{ vars.DOCKER_CONTAINER_NAME }}
  DOCKER_HOST_PORT: ${{ vars.DOCKER_HOST_PORT }} #Esto debe desaparecer en un futuro

  #########################################
  #   BLUE-GREEN DEPLOYMENT
  #########################################
  BLUE_PORT: ${{ vars.HOST_PORT_BLUE }}
  GREEN_PORT: ${{ vars.HOST_PORT_GREEN }}
  
  DOCKER_CONTAINER_PORT: ${{ vars.DOCKER_CONTAINER_PORT }}
  GMAIL_USER: ${{ secrets.GMAIL_USER }}
  GMAIL_RECIPIENTS: ${{ secrets.GMAIL_RECIPIENTS }}
  GMAIL_APP_PASSWORD: ${{ secrets.GMAIL_APP_PASSWORD }}
  SHOULD_ROBOTS_INDEX: ${{ vars.SHOULD_ROBOTS_INDEX }}

  NEXT_PUBLIC_BASE_URL: ${{ vars.NEXT_PUBLIC_BASE_URL }}
  NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME: ${{ secrets.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME }}
  NEXT_PUBLIC_GOOGLE_ANALYTICS_ID: ${{ secrets.NEXT_PUBLIC_GOOGLE_ANALYTICS_ID }}

jobs:
  retrieve-environment-variable:
    name: Retrieve Environment Variable
    uses: ./.github/workflows/retrieve_environment.yml

  build-push-docker-image:
    name: Build and Push Docker Image
    needs: retrieve-environment-variable
    runs-on: ubuntu-latest
    environment: ${{ needs.retrieve-environment-variable.outputs.environment_name }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          ref: ${{ github.ref }}

      - name: Build Docker Image
        run: |
          docker build -t ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_IMAGE_VERSION }} \
          --build-arg NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME=${{env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME}} \
          --build-arg NEXT_PUBLIC_BASE_URL=${{env.NEXT_PUBLIC_BASE_URL}} \
          --build-arg NEXT_PUBLIC_GOOGLE_ANALYTICS_ID=${{env.NEXT_PUBLIC_GOOGLE_ANALYTICS_ID}} \
          --build-arg SHOULD_ROBOTS_INDEX='${{env.SHOULD_ROBOTS_INDEX}}' \
          .

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKER_HUB_USERNAME }}
          password: ${{ env.DOCKER_HUB_PASSWORD }}

      - name: Push Docker Image to Docker Hub
        run: docker push ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_IMAGE_VERSION }}

  blue-green-deployment:
    name: Blue-Green Deployment
    runs-on: self-hosted
    needs: [retrieve-environment-variable, build-push-docker-image]
    environment: ${{ needs.retrieve-environment-variable.outputs.environment_name }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          ref: ${{ github.ref }}

      - name: Determine Active Port
        id: determine-port
        run: |
          echo "üîç Detectando puerto activo actual..."
          
          # Funci√≥n para verificar si un puerto est√° activo y saludable
          check_port_health() {
            local port=$1
            if echo ${{ env.SHH_USER_PASSWORD }} | sudo -S docker ps --format "table {{.Names}}\t{{.Ports}}" | grep -q ":${port}->"; then
              # Verificar que el puerto responda a health check
              # if curl -f -s "http://localhost:${port}/health" > /dev/null 2>&1; then
              #   return 0
              # fi
              return 0
            fi
            return 1
          }
          
          # Verificar estado de los puertos
          blue_healthy=false
          green_healthy=false
          
          if check_port_health ${{ env.BLUE_PORT }}; then
            blue_healthy=true
            echo "üîµ Puerto BLUE (${{ env.BLUE_PORT }}) est√° ACTIVO actualmente"
          else
            echo "‚ö™ Puerto BLUE (${{ env.BLUE_PORT }}) est√° DISPONIBLE para el nuevo deploy"
          fi
          
          if check_port_health ${{ env.GREEN_PORT }}; then
            green_healthy=true
            echo "üü¢ Puerto GREEN (${{ env.GREEN_PORT }}) est√° ACTIVO actualmente"
          else
            echo "‚ö™ Puerto GREEN (${{ env.GREEN_PORT }}) est√° DISPONIBLE para el nuevo deploy"
          fi
          
          # Determinar configuraci√≥n de despliegue
          if [ "$blue_healthy" = true ] && [ "$green_healthy" = false ]; then
            # Blue activo, desplegar en Green
            echo "üîÑ Estrategia: Desplegar en GREEN (puerto ${{ env.GREEN_PORT }}) mientras BLUE sigue activo"
            echo "active_port=${{ env.BLUE_PORT }}" >> $GITHUB_OUTPUT
            echo "new_port=${{ env.GREEN_PORT }}" >> $GITHUB_OUTPUT
            echo "active_container=${{ env.DOCKER_CONTAINER_NAME }}-blue" >> $GITHUB_OUTPUT
            echo "new_container=${{ env.DOCKER_CONTAINER_NAME }}-green" >> $GITHUB_OUTPUT
          elif [ "$green_healthy" = true ] && [ "$blue_healthy" = false ]; then
            # Green activo, desplegar en Blue
            echo "üîÑ Estrategia: Desplegar en BLUE (puerto ${{ env.BLUE_PORT }}) mientras GREEN sigue activo"
            echo "active_port=${{ env.GREEN_PORT }}" >> $GITHUB_OUTPUT
            echo "new_port=${{ env.BLUE_PORT }}" >> $GITHUB_OUTPUT
            echo "active_container=${{ env.DOCKER_CONTAINER_NAME }}-green" >> $GITHUB_OUTPUT
            echo "new_container=${{ env.DOCKER_CONTAINER_NAME }}-blue" >> $GITHUB_OUTPUT
          elif [ "$blue_healthy" = false ] && [ "$green_healthy" = false ]; then
            # Ninguno activo, usar Blue como default
            echo "üöÄ Estrategia: Primer deploy - iniciando en GREEN (puerto ${{ env.GREEN_PORT }})"
            echo "active_port=" >> $GITHUB_OUTPUT
            echo "new_port=${{ env.GREEN_PORT }}" >> $GITHUB_OUTPUT
            echo "active_container=" >> $GITHUB_OUTPUT
            echo "new_container=${{ env.DOCKER_CONTAINER_NAME }}-blue" >> $GITHUB_OUTPUT
          else
            # Ambos activos - estado inconsistente
            echo "‚ö†Ô∏è ADVERTENCIA: Ambos puertos est√°n activos. Limpiando estado inconsistente..."
            echo ${{ env.SHH_USER_PASSWORD }} | sudo -S docker rm -f ${{ env.DOCKER_CONTAINER_NAME }}-green || true
            echo "üîÑ Estrategia: Desplegar en GREEN (puerto ${{ env.GREEN_PORT }}) despu√©s de limpieza"
            echo "active_port=${{ env.BLUE_PORT }}" >> $GITHUB_OUTPUT
            echo "new_port=${{ env.GREEN_PORT }}" >> $GITHUB_OUTPUT
            echo "active_container=${{ env.DOCKER_CONTAINER_NAME }}-blue" >> $GITHUB_OUTPUT
            echo "new_container=${{ env.DOCKER_CONTAINER_NAME }}-green" >> $GITHUB_OUTPUT
          fi

      - name: Pull New Docker Image
        run: |
          echo ${{ env.SHH_USER_PASSWORD }} | sudo -S docker pull ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_IMAGE_VERSION }}

      - name: Deploy New Instance
        run: |
          # Limpiar SOLO el contenedor del puerto destino (si hay alguno previo fallido)
          echo ${{ env.SHH_USER_PASSWORD }} | sudo -S docker rm -f ${{ steps.determine-port.outputs.new_container }} || true
          
          # Levantar la nueva instancia en el puerto libre (SIN TOCAR el contenedor activo)
          echo "üöÄ Desplegando nueva instancia en puerto ${{ steps.determine-port.outputs.new_port }}..."
          echo ${{ env.SHH_USER_PASSWORD }} | sudo -S docker run -d \
            --name ${{ steps.determine-port.outputs.new_container }} \
            --restart unless-stopped \
            -p ${{ steps.determine-port.outputs.new_port }}:${{ env.DOCKER_CONTAINER_PORT }} \
            -e GMAIL_USER=${{ env.GMAIL_USER }} \
            -e GMAIL_RECIPIENTS=${{ env.GMAIL_RECIPIENTS }} \
            -e GMAIL_APP_PASSWORD='${{ env.GMAIL_APP_PASSWORD }}' \
            -e SHOULD_ROBOTS_INDEX='${{ env.SHOULD_ROBOTS_INDEX }}' \
            -e NEXT_PUBLIC_BASE_URL=${{ env.NEXT_PUBLIC_BASE_URL }} \
            -e NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME=${{ env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME }} \
            -e NEXT_PUBLIC_GOOGLE_ANALYTICS_ID=${{ env.NEXT_PUBLIC_GOOGLE_ANALYTICS_ID }} \
            ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_IMAGE_VERSION }}
          
          echo "‚úÖ Nueva instancia desplegada. Contenedor activo anterior sigue corriendo para zero-downtime"

      - name: Wait for New Instance Health Check
        run: |
          echo "üè• Esperando que la nueva instancia est√© saludable..."
          max_attempts=30
          attempt=1
          healthy=false
          
          while [ $attempt -le $max_attempts ]; do
            echo "‚è≥ Intento $attempt/$max_attempts - Verificando health check..."
            
            # Verificar health check de la aplicaci√≥n
            if curl -f -s http://localhost:${{ steps.determine-port.outputs.new_port }}/health > /dev/null 2>&1; then
              echo "‚úÖ Health check de aplicaci√≥n: OK"
              
              # Verificar que el contenedor est√© realmente saludable via Docker
              container_health=$(echo ${{ env.SHH_USER_PASSWORD }} | sudo -S docker inspect ${{ steps.determine-port.outputs.new_container }} --format='{{.State.Health.Status}}' 2>/dev/null || echo "no-healthcheck")
              
              if [ "$container_health" = "healthy" ] || [ "$container_health" = "no-healthcheck" ]; then
                echo "‚úÖ Container health: $container_health"
                
                # Verificar que responda correctamente m√∫ltiples veces
                success_count=0
                for i in {1..5}; do
                  if curl -f -s http://localhost:${{ steps.determine-port.outputs.new_port }}/health > /dev/null 2>&1; then
                    success_count=$((success_count + 1))
                  fi
                  sleep 1
                done
                
                if [ $success_count -ge 4 ]; then
                  echo "‚úÖ Nueva instancia est√° consistentemente saludable en puerto ${{ steps.determine-port.outputs.new_port }}"
                  healthy=true
                  break
                else
                  echo "‚ö†Ô∏è Respuestas inconsistentes ($success_count/5), continuando..."
                fi
              else
                echo "‚ö†Ô∏è Container health: $container_health"
              fi
            else
              echo "‚ùå Health check fall√≥"
            fi
            
            sleep 10
            attempt=$((attempt + 1))
          done
          
          if [ "$healthy" = false ]; then
            echo "‚ùå La nueva instancia no pas√≥ el health check despu√©s de $max_attempts intentos"
            echo "üîÑ Iniciando rollback autom√°tico..."
            
            # Cleanup de la nueva instancia fallida
            echo ${{ env.SHH_USER_PASSWORD }} | sudo -S docker rm -f ${{ steps.determine-port.outputs.new_container }} || true
            
            exit 1
          fi

      - name: Verify New Instance is Ready
        run: |
          echo "Verificando que la nueva instancia est√© lista para recibir tr√°fico..."
          max_attempts=10
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            # Verificar SOLO la nueva instancia directamente (no a trav√©s de Nginx)
            if curl -f http://localhost:${{ steps.determine-port.outputs.new_port }}/health > /dev/null 2>&1; then
              echo "‚úÖ Nueva instancia est√° lista en puerto ${{ steps.determine-port.outputs.new_port }}"
              echo "‚ÑπÔ∏è Nginx detectar√° autom√°ticamente el cambio cuando se detenga la instancia anterior"
              break
            fi
            echo "‚è≥ Intento $attempt/$max_attempts - Verificando nueva instancia..."
            echo "   - Puerto ${{ steps.determine-port.outputs.new_port }}: $(curl -f http://localhost:${{ steps.determine-port.outputs.new_port }}/health > /dev/null 2>&1 && echo "OK" || echo "FAIL")"
            sleep 5
            attempt=$((attempt + 1))
          done
          
          if [ $attempt -gt $max_attempts ]; then
            echo "‚ùå La nueva instancia no est√° sirviendo tr√°fico correctamente"
            exit 1
          fi

      - name: Stop Old Instance
        run: |
          # Detener la instancia anterior SOLO despu√©s de confirmar que la nueva funciona correctamente
          if [ -n "${{ steps.determine-port.outputs.active_container }}" ]; then
            echo "üîÑ Blue-Green Switch: Deteniendo instancia anterior ahora que la nueva est√° funcionando..."
            echo ${{ env.SHH_USER_PASSWORD }} | sudo -S docker rm -f ${{ steps.determine-port.outputs.active_container }} || true
            echo "‚úÖ Zero-downtime completado: ${{ steps.determine-port.outputs.active_container }} ‚Üí ${{ steps.determine-port.outputs.new_container }}"
          else
            echo "‚ÑπÔ∏è Primer deployment - no hab√≠a instancia anterior que detener"
          fi

      - name: Verify Nginx is Serving New Instance
        run: |
          echo "üîç Verificando que Nginx est√© sirviendo la nueva instancia..."
          max_attempts=10
          attempt=1
          
          # Dar tiempo a Nginx para detectar que la instancia anterior se detuvo
          sleep 5
          
          while [ $attempt -le $max_attempts ]; do
            # Verificar que Nginx est√© sirviendo la nueva instancia correctamente
            if curl -f http://localhost:${{ steps.determine-port.outputs.new_port }}/health > /dev/null 2>&1; then
              echo "‚úÖ Nginx est√° sirviendo correctamente la nueva instancia"
              echo "üéØ Tr√°fico fluyendo: puerto 80 ‚Üí puerto ${{ steps.determine-port.outputs.new_port }}"
              break
            fi
            echo "‚è≥ Intento $attempt/$max_attempts - Esperando que Nginx detecte el cambio..."
            echo "   - Verificando a trav√©s de Nginx (puerto 80): $(curl -f http://localhost:${{ steps.determine-port.outputs.new_port }}/health > /dev/null 2>&1 && echo "OK" || echo "FAIL")"
            sleep 3
            attempt=$((attempt + 1))
          done
          
          if [ $attempt -gt $max_attempts ]; then
            echo "‚ùå Nginx no est√° sirviendo correctamente a trav√©s del puerto 80"
            echo "üîß Posible soluci√≥n: verificar configuraci√≥n de Nginx"
            exit 1
          fi

      - name: Deployment Summary
        run: |
          echo "üéâ Blue-Green Deployment Completado Exitosamente!"
          echo "üìä Resumen del despliegue:"
          echo "   - Puerto activo: ${{ steps.determine-port.outputs.new_port }}"
          echo "   - Contenedor activo: ${{ steps.determine-port.outputs.new_container }}"
          echo "   - Imagen: ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_IMAGE_VERSION }}"
          echo "   - Nginx: Sistema (no contenedor)"
          
          echo ${{ env.SHH_USER_PASSWORD }} | sudo -S docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          echo ${{ env.SHH_USER_PASSWORD }} | sudo -S systemctl status nginx --no-pager -l

      # - name: Prune Docker Images unused
      #   run: |
      #     echo ${{ env.SHH_USER_PASSWORD }} | sudo -S docker image prune -f    
  # pull-frontend-image-and-run-container:
  #   name: Deploy Frontend Container
  #   runs-on: self-hosted
  #   needs: [retrieve-environment-variable, build-push-docker-image]
  #   environment: ${{ needs.retrieve-environment-variable.outputs.environment_name }}
  #   steps:      
  #     - name: Pull Docker Image
  #       run: |
  #         echo ${{ env.SHH_USER_PASSWORD }} | sudo -S docker pull ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_IMAGE_VERSION }}
      
  #     - name: Stop Current Running Container
  #       run: |
  #         echo ${{ env.SHH_USER_PASSWORD }} | sudo -S docker rm -f ${{ env.DOCKER_CONTAINER_NAME }} || true
      
  #     - name: Run Docker Container
  #       run: |
  #         echo ${{ env.SHH_USER_PASSWORD }} | sudo -S docker run -d \
  #           --restart unless-stopped \
  #           -p ${{ env.DOCKER_HOST_PORT }}:${{ env.DOCKER_CONTAINER_PORT }} \
  #           -e GMAIL_USER=${{ env.GMAIL_USER }} \
  #           -e GMAIL_RECIPIENTS=${{ env.GMAIL_RECIPIENTS }} \
  #           -e GMAIL_APP_PASSWORD='${{ env.GMAIL_APP_PASSWORD }}' \
  #           -e SHOULD_ROBOTS_INDEX='${{ env.SHOULD_ROBOTS_INDEX }}' \
  #           -e NEXT_PUBLIC_BASE_URL=${{ env.NEXT_PUBLIC_BASE_URL }} \
  #           -e NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME=${{ env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME }} \
  #           -e NEXT_PUBLIC_GOOGLE_ANALYTICS_ID=${{ env.NEXT_PUBLIC_GOOGLE_ANALYTICS_ID }} \
  #           --name ${{ env.DOCKER_CONTAINER_NAME }} \
  #           ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_IMAGE_VERSION }}
            
  #     - name: Prune Docker Images unused
  #       run: |
  #         echo ${{ env.SHH_USER_PASSWORD }} | sudo -S docker image prune -f